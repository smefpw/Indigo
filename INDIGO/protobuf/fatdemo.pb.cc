// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fatdemo.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "fatdemo.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* MLDict_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MLDict_reflection_ = NULL;
const ::google::protobuf::Descriptor* MLEvent_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MLEvent_reflection_ = NULL;
const ::google::protobuf::Descriptor* MLMatchState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MLMatchState_reflection_ = NULL;
const ::google::protobuf::Descriptor* MLRoundState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MLRoundState_reflection_ = NULL;
const ::google::protobuf::Descriptor* MLWeaponState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MLWeaponState_reflection_ = NULL;
const ::google::protobuf::Descriptor* MLPlayerState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MLPlayerState_reflection_ = NULL;
const ::google::protobuf::Descriptor* MLGameState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MLGameState_reflection_ = NULL;
const ::google::protobuf::Descriptor* MLDemoHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MLDemoHeader_reflection_ = NULL;
const ::google::protobuf::Descriptor* MLTick_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MLTick_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* EHitGroup_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ETeam_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* EWeaponType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_fatdemo_2eproto() {
  protobuf_AddDesc_fatdemo_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "fatdemo.proto");
  GOOGLE_CHECK(file != NULL);
  MLDict_descriptor_ = file->message_type(0);
  static const int MLDict_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLDict, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLDict, val_string_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLDict, val_int_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLDict, val_float_),
  };
  MLDict_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MLDict_descriptor_,
      MLDict::default_instance_,
      MLDict_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLDict, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLDict, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MLDict));
  MLEvent_descriptor_ = file->message_type(1);
  static const int MLEvent_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLEvent, event_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLEvent, data_),
  };
  MLEvent_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MLEvent_descriptor_,
      MLEvent::default_instance_,
      MLEvent_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLEvent, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLEvent, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MLEvent));
  MLMatchState_descriptor_ = file->message_type(2);
  static const int MLMatchState_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLMatchState, game_mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLMatchState, phase_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLMatchState, round_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLMatchState, score_ct_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLMatchState, score_t_),
  };
  MLMatchState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MLMatchState_descriptor_,
      MLMatchState::default_instance_,
      MLMatchState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLMatchState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLMatchState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MLMatchState));
  MLRoundState_descriptor_ = file->message_type(3);
  static const int MLRoundState_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLRoundState, phase_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLRoundState, win_team_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLRoundState, bomb_state_),
  };
  MLRoundState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MLRoundState_descriptor_,
      MLRoundState::default_instance_,
      MLRoundState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLRoundState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLRoundState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MLRoundState));
  MLWeaponState_descriptor_ = file->message_type(4);
  static const int MLWeaponState_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLWeaponState, index_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLWeaponState, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLWeaponState, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLWeaponState, ammo_clip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLWeaponState, ammo_clip_max_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLWeaponState, ammo_reserve_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLWeaponState, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLWeaponState, recoil_index_),
  };
  MLWeaponState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MLWeaponState_descriptor_,
      MLWeaponState::default_instance_,
      MLWeaponState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLWeaponState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLWeaponState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MLWeaponState));
  MLPlayerState_descriptor_ = file->message_type(5);
  static const int MLPlayerState_offsets_[20] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLPlayerState, account_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLPlayerState, user_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLPlayerState, entindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLPlayerState, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLPlayerState, clan_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLPlayerState, team_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLPlayerState, abspos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLPlayerState, eyeangle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLPlayerState, eyeangle_fwd_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLPlayerState, health_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLPlayerState, armor_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLPlayerState, flashed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLPlayerState, smoked_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLPlayerState, money_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLPlayerState, round_kills_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLPlayerState, round_killhs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLPlayerState, burning_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLPlayerState, helmet_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLPlayerState, defuse_kit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLPlayerState, weapons_),
  };
  MLPlayerState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MLPlayerState_descriptor_,
      MLPlayerState::default_instance_,
      MLPlayerState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLPlayerState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLPlayerState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MLPlayerState));
  MLGameState_descriptor_ = file->message_type(6);
  static const int MLGameState_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLGameState, match_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLGameState, round_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLGameState, players_),
  };
  MLGameState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MLGameState_descriptor_,
      MLGameState::default_instance_,
      MLGameState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLGameState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLGameState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MLGameState));
  MLDemoHeader_descriptor_ = file->message_type(7);
  static const int MLDemoHeader_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLDemoHeader, map_name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLDemoHeader, tick_rate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLDemoHeader, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLDemoHeader, steam_universe_),
  };
  MLDemoHeader_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MLDemoHeader_descriptor_,
      MLDemoHeader::default_instance_,
      MLDemoHeader_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLDemoHeader, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLDemoHeader, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MLDemoHeader));
  MLTick_descriptor_ = file->message_type(8);
  static const int MLTick_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLTick, tick_count_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLTick, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLTick, events_),
  };
  MLTick_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MLTick_descriptor_,
      MLTick::default_instance_,
      MLTick_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLTick, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MLTick, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MLTick));
  EHitGroup_descriptor_ = file->enum_type(0);
  ETeam_descriptor_ = file->enum_type(1);
  EWeaponType_descriptor_ = file->enum_type(2);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_fatdemo_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MLDict_descriptor_, &MLDict::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MLEvent_descriptor_, &MLEvent::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MLMatchState_descriptor_, &MLMatchState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MLRoundState_descriptor_, &MLRoundState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MLWeaponState_descriptor_, &MLWeaponState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MLPlayerState_descriptor_, &MLPlayerState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MLGameState_descriptor_, &MLGameState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MLDemoHeader_descriptor_, &MLDemoHeader::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MLTick_descriptor_, &MLTick::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_fatdemo_2eproto() {
  delete MLDict::default_instance_;
  delete MLDict_reflection_;
  delete MLEvent::default_instance_;
  delete MLEvent_reflection_;
  delete MLMatchState::default_instance_;
  delete MLMatchState_reflection_;
  delete MLRoundState::default_instance_;
  delete MLRoundState_reflection_;
  delete MLWeaponState::default_instance_;
  delete MLWeaponState_reflection_;
  delete MLPlayerState::default_instance_;
  delete MLPlayerState_reflection_;
  delete MLGameState::default_instance_;
  delete MLGameState_reflection_;
  delete MLDemoHeader::default_instance_;
  delete MLDemoHeader_reflection_;
  delete MLTick::default_instance_;
  delete MLTick_reflection_;
}

void protobuf_AddDesc_fatdemo_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::protobuf_AddDesc_netmessages_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\rfatdemo.proto\032\021netmessages.proto\"M\n\006ML"
    "Dict\022\013\n\003key\030\001 \001(\t\022\022\n\nval_string\030\002 \001(\t\022\017\n"
    "\007val_int\030\003 \001(\005\022\021\n\tval_float\030\004 \001(\002\"4\n\007MLE"
    "vent\022\022\n\nevent_name\030\001 \001(\t\022\025\n\004data\030\002 \003(\0132\007"
    ".MLDict\"b\n\014MLMatchState\022\021\n\tgame_mode\030\001 \001"
    "(\t\022\r\n\005phase\030\002 \001(\t\022\r\n\005round\030\003 \001(\005\022\020\n\010scor"
    "e_ct\030\004 \001(\005\022\017\n\007score_t\030\005 \001(\005\"W\n\014MLRoundSt"
    "ate\022\r\n\005phase\030\001 \001(\t\022$\n\010win_team\030\002 \001(\0162\006.E"
    "Team:\nET_Unknown\022\022\n\nbomb_state\030\003 \001(\t\"\270\001\n"
    "\rMLWeaponState\022\r\n\005index\030\001 \001(\005\022\014\n\004name\030\002 "
    "\001(\t\022%\n\004type\030\003 \001(\0162\014.EWeaponType:\tEWT_Kni"
    "fe\022\021\n\tammo_clip\030\004 \001(\005\022\025\n\rammo_clip_max\030\005"
    " \001(\005\022\024\n\014ammo_reserve\030\006 \001(\005\022\r\n\005state\030\007 \001("
    "\t\022\024\n\014recoil_index\030\010 \001(\002\"\263\003\n\rMLPlayerStat"
    "e\022\022\n\naccount_id\030\001 \001(\005\022\017\n\007user_id\030\002 \001(\005\022\020"
    "\n\010entindex\030\003 \001(\005\022\014\n\004name\030\004 \001(\t\022\014\n\004clan\030\005"
    " \001(\t\022 \n\004team\030\006 \001(\0162\006.ETeam:\nET_Unknown\022\033"
    "\n\006abspos\030\007 \001(\0132\013.CMsgVector\022\035\n\010eyeangle\030"
    "\010 \001(\0132\013.CMsgQAngle\022!\n\014eyeangle_fwd\030\t \001(\013"
    "2\013.CMsgVector\022\016\n\006health\030\n \001(\005\022\r\n\005armor\030\013"
    " \001(\005\022\017\n\007flashed\030\014 \001(\002\022\016\n\006smoked\030\r \001(\002\022\r\n"
    "\005money\030\016 \001(\005\022\023\n\013round_kills\030\017 \001(\005\022\024\n\014rou"
    "nd_killhs\030\020 \001(\005\022\017\n\007burning\030\021 \001(\002\022\016\n\006helm"
    "et\030\022 \001(\010\022\022\n\ndefuse_kit\030\023 \001(\010\022\037\n\007weapons\030"
    "\024 \003(\0132\016.MLWeaponState\"j\n\013MLGameState\022\034\n\005"
    "match\030\001 \001(\0132\r.MLMatchState\022\034\n\005round\030\002 \001("
    "\0132\r.MLRoundState\022\037\n\007players\030\003 \003(\0132\016.MLPl"
    "ayerState\"\\\n\014MLDemoHeader\022\020\n\010map_name\030\001 "
    "\001(\t\022\021\n\ttick_rate\030\002 \001(\005\022\017\n\007version\030\003 \001(\r\022"
    "\026\n\016steam_universe\030\004 \001(\r\"S\n\006MLTick\022\022\n\ntic"
    "k_count\030\001 \001(\005\022\033\n\005state\030\002 \001(\0132\014.MLGameSta"
    "te\022\030\n\006events\030\003 \003(\0132\010.MLEvent*\254\001\n\tEHitGro"
    "up\022\017\n\013EHG_Generic\020\000\022\014\n\010EHG_Head\020\001\022\r\n\tEHG"
    "_Chest\020\002\022\017\n\013EHG_Stomach\020\003\022\017\n\013EHG_LeftArm"
    "\020\004\022\020\n\014EHG_RightArm\020\005\022\017\n\013EHG_LeftLeg\020\006\022\020\n"
    "\014EHG_RightLeg\020\007\022\014\n\010EHG_Gear\020\010\022\014\n\010EHG_Mis"
    "s\020\t*F\n\005ETeam\022\016\n\nET_Unknown\020\000\022\020\n\014ET_Spect"
    "ator\020\001\022\020\n\014ET_Terrorist\020\002\022\t\n\005ET_CT\020\003*\344\001\n\013"
    "EWeaponType\022\r\n\tEWT_Knife\020\000\022\016\n\nEWT_Pistol"
    "\020\001\022\025\n\021EWT_SubMachineGun\020\002\022\r\n\tEWT_Rifle\020\003"
    "\022\017\n\013EWT_Shotgun\020\004\022\023\n\017EWT_SniperRifle\020\005\022\022"
    "\n\016EWT_MachineGun\020\006\022\n\n\006EWT_C4\020\007\022\017\n\013EWT_Gr"
    "enade\020\010\022\021\n\rEWT_Equipment\020\t\022\025\n\021EWT_Stacka"
    "bleItem\020\n\022\017\n\013EWT_Unknown\020\013", 1746);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "fatdemo.proto", &protobuf_RegisterTypes);
  MLDict::default_instance_ = new MLDict();
  MLEvent::default_instance_ = new MLEvent();
  MLMatchState::default_instance_ = new MLMatchState();
  MLRoundState::default_instance_ = new MLRoundState();
  MLWeaponState::default_instance_ = new MLWeaponState();
  MLPlayerState::default_instance_ = new MLPlayerState();
  MLGameState::default_instance_ = new MLGameState();
  MLDemoHeader::default_instance_ = new MLDemoHeader();
  MLTick::default_instance_ = new MLTick();
  MLDict::default_instance_->InitAsDefaultInstance();
  MLEvent::default_instance_->InitAsDefaultInstance();
  MLMatchState::default_instance_->InitAsDefaultInstance();
  MLRoundState::default_instance_->InitAsDefaultInstance();
  MLWeaponState::default_instance_->InitAsDefaultInstance();
  MLPlayerState::default_instance_->InitAsDefaultInstance();
  MLGameState::default_instance_->InitAsDefaultInstance();
  MLDemoHeader::default_instance_->InitAsDefaultInstance();
  MLTick::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_fatdemo_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_fatdemo_2eproto {
  StaticDescriptorInitializer_fatdemo_2eproto() {
    protobuf_AddDesc_fatdemo_2eproto();
  }
} static_descriptor_initializer_fatdemo_2eproto_;
const ::google::protobuf::EnumDescriptor* EHitGroup_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EHitGroup_descriptor_;
}
bool EHitGroup_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ETeam_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ETeam_descriptor_;
}
bool ETeam_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* EWeaponType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return EWeaponType_descriptor_;
}
bool EWeaponType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int MLDict::kKeyFieldNumber;
const int MLDict::kValStringFieldNumber;
const int MLDict::kValIntFieldNumber;
const int MLDict::kValFloatFieldNumber;
#endif  // !_MSC_VER

MLDict::MLDict()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MLDict::InitAsDefaultInstance() {
}

MLDict::MLDict(const MLDict& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MLDict::SharedCtor() {
  _cached_size_ = 0;
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  val_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  val_int_ = 0;
  val_float_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MLDict::~MLDict() {
  SharedDtor();
}

void MLDict::SharedDtor() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (val_string_ != &::google::protobuf::internal::kEmptyString) {
    delete val_string_;
  }
  if (this != default_instance_) {
  }
}

void MLDict::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MLDict::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MLDict_descriptor_;
}

const MLDict& MLDict::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_fatdemo_2eproto();
  return *default_instance_;
}

MLDict* MLDict::default_instance_ = NULL;

MLDict* MLDict::New() const {
  return new MLDict;
}

void MLDict::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::kEmptyString) {
        key_->clear();
      }
    }
    if (has_val_string()) {
      if (val_string_ != &::google::protobuf::internal::kEmptyString) {
        val_string_->clear();
      }
    }
    val_int_ = 0;
    val_float_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MLDict::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string key = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->key().data(), this->key().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_val_string;
        break;
      }

      // optional string val_string = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_val_string:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_val_string()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->val_string().data(), this->val_string().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_val_int;
        break;
      }

      // optional int32 val_int = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_val_int:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &val_int_)));
          set_has_val_int();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_val_float;
        break;
      }

      // optional float val_float = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_val_float:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &val_float_)));
          set_has_val_float();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MLDict::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->key(), output);
  }

  // optional string val_string = 2;
  if (has_val_string()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->val_string().data(), this->val_string().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->val_string(), output);
  }

  // optional int32 val_int = 3;
  if (has_val_int()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->val_int(), output);
  }

  // optional float val_float = 4;
  if (has_val_float()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->val_float(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MLDict::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->key(), target);
  }

  // optional string val_string = 2;
  if (has_val_string()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->val_string().data(), this->val_string().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->val_string(), target);
  }

  // optional int32 val_int = 3;
  if (has_val_int()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->val_int(), target);
  }

  // optional float val_float = 4;
  if (has_val_float()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->val_float(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MLDict::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string key = 1;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key());
    }

    // optional string val_string = 2;
    if (has_val_string()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->val_string());
    }

    // optional int32 val_int = 3;
    if (has_val_int()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->val_int());
    }

    // optional float val_float = 4;
    if (has_val_float()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MLDict::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MLDict* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MLDict*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MLDict::MergeFrom(const MLDict& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_val_string()) {
      set_val_string(from.val_string());
    }
    if (from.has_val_int()) {
      set_val_int(from.val_int());
    }
    if (from.has_val_float()) {
      set_val_float(from.val_float());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MLDict::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MLDict::CopyFrom(const MLDict& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MLDict::IsInitialized() const {

  return true;
}

void MLDict::Swap(MLDict* other) {
  if (other != this) {
    std::swap(key_, other->key_);
    std::swap(val_string_, other->val_string_);
    std::swap(val_int_, other->val_int_);
    std::swap(val_float_, other->val_float_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MLDict::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MLDict_descriptor_;
  metadata.reflection = MLDict_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MLEvent::kEventNameFieldNumber;
const int MLEvent::kDataFieldNumber;
#endif  // !_MSC_VER

MLEvent::MLEvent()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MLEvent::InitAsDefaultInstance() {
}

MLEvent::MLEvent(const MLEvent& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MLEvent::SharedCtor() {
  _cached_size_ = 0;
  event_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MLEvent::~MLEvent() {
  SharedDtor();
}

void MLEvent::SharedDtor() {
  if (event_name_ != &::google::protobuf::internal::kEmptyString) {
    delete event_name_;
  }
  if (this != default_instance_) {
  }
}

void MLEvent::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MLEvent::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MLEvent_descriptor_;
}

const MLEvent& MLEvent::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_fatdemo_2eproto();
  return *default_instance_;
}

MLEvent* MLEvent::default_instance_ = NULL;

MLEvent* MLEvent::New() const {
  return new MLEvent;
}

void MLEvent::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_event_name()) {
      if (event_name_ != &::google::protobuf::internal::kEmptyString) {
        event_name_->clear();
      }
    }
  }
  data_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MLEvent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string event_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_event_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->event_name().data(), this->event_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }

      // repeated .MLDict data = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_data()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_data;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MLEvent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string event_name = 1;
  if (has_event_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->event_name().data(), this->event_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->event_name(), output);
  }

  // repeated .MLDict data = 2;
  for (int i = 0; i < this->data_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->data(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MLEvent::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string event_name = 1;
  if (has_event_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->event_name().data(), this->event_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->event_name(), target);
  }

  // repeated .MLDict data = 2;
  for (int i = 0; i < this->data_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->data(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MLEvent::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string event_name = 1;
    if (has_event_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->event_name());
    }

  }
  // repeated .MLDict data = 2;
  total_size += 1 * this->data_size();
  for (int i = 0; i < this->data_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->data(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MLEvent::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MLEvent* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MLEvent*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MLEvent::MergeFrom(const MLEvent& from) {
  GOOGLE_CHECK_NE(&from, this);
  data_.MergeFrom(from.data_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_event_name()) {
      set_event_name(from.event_name());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MLEvent::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MLEvent::CopyFrom(const MLEvent& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MLEvent::IsInitialized() const {

  return true;
}

void MLEvent::Swap(MLEvent* other) {
  if (other != this) {
    std::swap(event_name_, other->event_name_);
    data_.Swap(&other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MLEvent::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MLEvent_descriptor_;
  metadata.reflection = MLEvent_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MLMatchState::kGameModeFieldNumber;
const int MLMatchState::kPhaseFieldNumber;
const int MLMatchState::kRoundFieldNumber;
const int MLMatchState::kScoreCtFieldNumber;
const int MLMatchState::kScoreTFieldNumber;
#endif  // !_MSC_VER

MLMatchState::MLMatchState()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MLMatchState::InitAsDefaultInstance() {
}

MLMatchState::MLMatchState(const MLMatchState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MLMatchState::SharedCtor() {
  _cached_size_ = 0;
  game_mode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  phase_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  round_ = 0;
  score_ct_ = 0;
  score_t_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MLMatchState::~MLMatchState() {
  SharedDtor();
}

void MLMatchState::SharedDtor() {
  if (game_mode_ != &::google::protobuf::internal::kEmptyString) {
    delete game_mode_;
  }
  if (phase_ != &::google::protobuf::internal::kEmptyString) {
    delete phase_;
  }
  if (this != default_instance_) {
  }
}

void MLMatchState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MLMatchState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MLMatchState_descriptor_;
}

const MLMatchState& MLMatchState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_fatdemo_2eproto();
  return *default_instance_;
}

MLMatchState* MLMatchState::default_instance_ = NULL;

MLMatchState* MLMatchState::New() const {
  return new MLMatchState;
}

void MLMatchState::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_game_mode()) {
      if (game_mode_ != &::google::protobuf::internal::kEmptyString) {
        game_mode_->clear();
      }
    }
    if (has_phase()) {
      if (phase_ != &::google::protobuf::internal::kEmptyString) {
        phase_->clear();
      }
    }
    round_ = 0;
    score_ct_ = 0;
    score_t_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MLMatchState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string game_mode = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_game_mode()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->game_mode().data(), this->game_mode().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_phase;
        break;
      }

      // optional string phase = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_phase:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_phase()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->phase().data(), this->phase().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_round;
        break;
      }

      // optional int32 round = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_round:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &round_)));
          set_has_round();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_score_ct;
        break;
      }

      // optional int32 score_ct = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_score_ct:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &score_ct_)));
          set_has_score_ct();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_score_t;
        break;
      }

      // optional int32 score_t = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_score_t:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &score_t_)));
          set_has_score_t();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MLMatchState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string game_mode = 1;
  if (has_game_mode()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->game_mode().data(), this->game_mode().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->game_mode(), output);
  }

  // optional string phase = 2;
  if (has_phase()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->phase().data(), this->phase().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->phase(), output);
  }

  // optional int32 round = 3;
  if (has_round()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->round(), output);
  }

  // optional int32 score_ct = 4;
  if (has_score_ct()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->score_ct(), output);
  }

  // optional int32 score_t = 5;
  if (has_score_t()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->score_t(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MLMatchState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string game_mode = 1;
  if (has_game_mode()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->game_mode().data(), this->game_mode().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->game_mode(), target);
  }

  // optional string phase = 2;
  if (has_phase()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->phase().data(), this->phase().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->phase(), target);
  }

  // optional int32 round = 3;
  if (has_round()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->round(), target);
  }

  // optional int32 score_ct = 4;
  if (has_score_ct()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->score_ct(), target);
  }

  // optional int32 score_t = 5;
  if (has_score_t()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->score_t(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MLMatchState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string game_mode = 1;
    if (has_game_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->game_mode());
    }

    // optional string phase = 2;
    if (has_phase()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->phase());
    }

    // optional int32 round = 3;
    if (has_round()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->round());
    }

    // optional int32 score_ct = 4;
    if (has_score_ct()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->score_ct());
    }

    // optional int32 score_t = 5;
    if (has_score_t()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->score_t());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MLMatchState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MLMatchState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MLMatchState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MLMatchState::MergeFrom(const MLMatchState& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_game_mode()) {
      set_game_mode(from.game_mode());
    }
    if (from.has_phase()) {
      set_phase(from.phase());
    }
    if (from.has_round()) {
      set_round(from.round());
    }
    if (from.has_score_ct()) {
      set_score_ct(from.score_ct());
    }
    if (from.has_score_t()) {
      set_score_t(from.score_t());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MLMatchState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MLMatchState::CopyFrom(const MLMatchState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MLMatchState::IsInitialized() const {

  return true;
}

void MLMatchState::Swap(MLMatchState* other) {
  if (other != this) {
    std::swap(game_mode_, other->game_mode_);
    std::swap(phase_, other->phase_);
    std::swap(round_, other->round_);
    std::swap(score_ct_, other->score_ct_);
    std::swap(score_t_, other->score_t_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MLMatchState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MLMatchState_descriptor_;
  metadata.reflection = MLMatchState_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MLRoundState::kPhaseFieldNumber;
const int MLRoundState::kWinTeamFieldNumber;
const int MLRoundState::kBombStateFieldNumber;
#endif  // !_MSC_VER

MLRoundState::MLRoundState()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MLRoundState::InitAsDefaultInstance() {
}

MLRoundState::MLRoundState(const MLRoundState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MLRoundState::SharedCtor() {
  _cached_size_ = 0;
  phase_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  win_team_ = 0;
  bomb_state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MLRoundState::~MLRoundState() {
  SharedDtor();
}

void MLRoundState::SharedDtor() {
  if (phase_ != &::google::protobuf::internal::kEmptyString) {
    delete phase_;
  }
  if (bomb_state_ != &::google::protobuf::internal::kEmptyString) {
    delete bomb_state_;
  }
  if (this != default_instance_) {
  }
}

void MLRoundState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MLRoundState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MLRoundState_descriptor_;
}

const MLRoundState& MLRoundState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_fatdemo_2eproto();
  return *default_instance_;
}

MLRoundState* MLRoundState::default_instance_ = NULL;

MLRoundState* MLRoundState::New() const {
  return new MLRoundState;
}

void MLRoundState::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_phase()) {
      if (phase_ != &::google::protobuf::internal::kEmptyString) {
        phase_->clear();
      }
    }
    win_team_ = 0;
    if (has_bomb_state()) {
      if (bomb_state_ != &::google::protobuf::internal::kEmptyString) {
        bomb_state_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MLRoundState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string phase = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_phase()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->phase().data(), this->phase().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_win_team;
        break;
      }

      // optional .ETeam win_team = 2 [default = ET_Unknown];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_win_team:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ETeam_IsValid(value)) {
            set_win_team(static_cast< ::ETeam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_bomb_state;
        break;
      }

      // optional string bomb_state = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bomb_state:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_bomb_state()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->bomb_state().data(), this->bomb_state().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MLRoundState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string phase = 1;
  if (has_phase()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->phase().data(), this->phase().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->phase(), output);
  }

  // optional .ETeam win_team = 2 [default = ET_Unknown];
  if (has_win_team()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->win_team(), output);
  }

  // optional string bomb_state = 3;
  if (has_bomb_state()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->bomb_state().data(), this->bomb_state().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->bomb_state(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MLRoundState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string phase = 1;
  if (has_phase()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->phase().data(), this->phase().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->phase(), target);
  }

  // optional .ETeam win_team = 2 [default = ET_Unknown];
  if (has_win_team()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->win_team(), target);
  }

  // optional string bomb_state = 3;
  if (has_bomb_state()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->bomb_state().data(), this->bomb_state().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->bomb_state(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MLRoundState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string phase = 1;
    if (has_phase()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->phase());
    }

    // optional .ETeam win_team = 2 [default = ET_Unknown];
    if (has_win_team()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->win_team());
    }

    // optional string bomb_state = 3;
    if (has_bomb_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->bomb_state());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MLRoundState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MLRoundState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MLRoundState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MLRoundState::MergeFrom(const MLRoundState& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_phase()) {
      set_phase(from.phase());
    }
    if (from.has_win_team()) {
      set_win_team(from.win_team());
    }
    if (from.has_bomb_state()) {
      set_bomb_state(from.bomb_state());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MLRoundState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MLRoundState::CopyFrom(const MLRoundState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MLRoundState::IsInitialized() const {

  return true;
}

void MLRoundState::Swap(MLRoundState* other) {
  if (other != this) {
    std::swap(phase_, other->phase_);
    std::swap(win_team_, other->win_team_);
    std::swap(bomb_state_, other->bomb_state_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MLRoundState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MLRoundState_descriptor_;
  metadata.reflection = MLRoundState_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MLWeaponState::kIndexFieldNumber;
const int MLWeaponState::kNameFieldNumber;
const int MLWeaponState::kTypeFieldNumber;
const int MLWeaponState::kAmmoClipFieldNumber;
const int MLWeaponState::kAmmoClipMaxFieldNumber;
const int MLWeaponState::kAmmoReserveFieldNumber;
const int MLWeaponState::kStateFieldNumber;
const int MLWeaponState::kRecoilIndexFieldNumber;
#endif  // !_MSC_VER

MLWeaponState::MLWeaponState()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MLWeaponState::InitAsDefaultInstance() {
}

MLWeaponState::MLWeaponState(const MLWeaponState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MLWeaponState::SharedCtor() {
  _cached_size_ = 0;
  index_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  type_ = 0;
  ammo_clip_ = 0;
  ammo_clip_max_ = 0;
  ammo_reserve_ = 0;
  state_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  recoil_index_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MLWeaponState::~MLWeaponState() {
  SharedDtor();
}

void MLWeaponState::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (state_ != &::google::protobuf::internal::kEmptyString) {
    delete state_;
  }
  if (this != default_instance_) {
  }
}

void MLWeaponState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MLWeaponState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MLWeaponState_descriptor_;
}

const MLWeaponState& MLWeaponState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_fatdemo_2eproto();
  return *default_instance_;
}

MLWeaponState* MLWeaponState::default_instance_ = NULL;

MLWeaponState* MLWeaponState::New() const {
  return new MLWeaponState;
}

void MLWeaponState::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    index_ = 0;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    type_ = 0;
    ammo_clip_ = 0;
    ammo_clip_max_ = 0;
    ammo_reserve_ = 0;
    if (has_state()) {
      if (state_ != &::google::protobuf::internal::kEmptyString) {
        state_->clear();
      }
    }
    recoil_index_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MLWeaponState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 index = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &index_)));
          set_has_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }

      // optional .EWeaponType type = 3 [default = EWT_Knife];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::EWeaponType_IsValid(value)) {
            set_type(static_cast< ::EWeaponType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_ammo_clip;
        break;
      }

      // optional int32 ammo_clip = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ammo_clip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ammo_clip_)));
          set_has_ammo_clip();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_ammo_clip_max;
        break;
      }

      // optional int32 ammo_clip_max = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ammo_clip_max:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ammo_clip_max_)));
          set_has_ammo_clip_max();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_ammo_reserve;
        break;
      }

      // optional int32 ammo_reserve = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ammo_reserve:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ammo_reserve_)));
          set_has_ammo_reserve();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_state;
        break;
      }

      // optional string state = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_state:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_state()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->state().data(), this->state().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(69)) goto parse_recoil_index;
        break;
      }

      // optional float recoil_index = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_recoil_index:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &recoil_index_)));
          set_has_recoil_index();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MLWeaponState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 index = 1;
  if (has_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->index(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }

  // optional .EWeaponType type = 3 [default = EWT_Knife];
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->type(), output);
  }

  // optional int32 ammo_clip = 4;
  if (has_ammo_clip()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->ammo_clip(), output);
  }

  // optional int32 ammo_clip_max = 5;
  if (has_ammo_clip_max()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->ammo_clip_max(), output);
  }

  // optional int32 ammo_reserve = 6;
  if (has_ammo_reserve()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->ammo_reserve(), output);
  }

  // optional string state = 7;
  if (has_state()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->state().data(), this->state().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->state(), output);
  }

  // optional float recoil_index = 8;
  if (has_recoil_index()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->recoil_index(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MLWeaponState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 index = 1;
  if (has_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->index(), target);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // optional .EWeaponType type = 3 [default = EWT_Knife];
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->type(), target);
  }

  // optional int32 ammo_clip = 4;
  if (has_ammo_clip()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->ammo_clip(), target);
  }

  // optional int32 ammo_clip_max = 5;
  if (has_ammo_clip_max()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->ammo_clip_max(), target);
  }

  // optional int32 ammo_reserve = 6;
  if (has_ammo_reserve()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->ammo_reserve(), target);
  }

  // optional string state = 7;
  if (has_state()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->state().data(), this->state().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->state(), target);
  }

  // optional float recoil_index = 8;
  if (has_recoil_index()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->recoil_index(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MLWeaponState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 index = 1;
    if (has_index()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->index());
    }

    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional .EWeaponType type = 3 [default = EWT_Knife];
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional int32 ammo_clip = 4;
    if (has_ammo_clip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ammo_clip());
    }

    // optional int32 ammo_clip_max = 5;
    if (has_ammo_clip_max()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ammo_clip_max());
    }

    // optional int32 ammo_reserve = 6;
    if (has_ammo_reserve()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ammo_reserve());
    }

    // optional string state = 7;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->state());
    }

    // optional float recoil_index = 8;
    if (has_recoil_index()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MLWeaponState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MLWeaponState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MLWeaponState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MLWeaponState::MergeFrom(const MLWeaponState& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_index()) {
      set_index(from.index());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_ammo_clip()) {
      set_ammo_clip(from.ammo_clip());
    }
    if (from.has_ammo_clip_max()) {
      set_ammo_clip_max(from.ammo_clip_max());
    }
    if (from.has_ammo_reserve()) {
      set_ammo_reserve(from.ammo_reserve());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_recoil_index()) {
      set_recoil_index(from.recoil_index());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MLWeaponState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MLWeaponState::CopyFrom(const MLWeaponState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MLWeaponState::IsInitialized() const {

  return true;
}

void MLWeaponState::Swap(MLWeaponState* other) {
  if (other != this) {
    std::swap(index_, other->index_);
    std::swap(name_, other->name_);
    std::swap(type_, other->type_);
    std::swap(ammo_clip_, other->ammo_clip_);
    std::swap(ammo_clip_max_, other->ammo_clip_max_);
    std::swap(ammo_reserve_, other->ammo_reserve_);
    std::swap(state_, other->state_);
    std::swap(recoil_index_, other->recoil_index_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MLWeaponState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MLWeaponState_descriptor_;
  metadata.reflection = MLWeaponState_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MLPlayerState::kAccountIdFieldNumber;
const int MLPlayerState::kUserIdFieldNumber;
const int MLPlayerState::kEntindexFieldNumber;
const int MLPlayerState::kNameFieldNumber;
const int MLPlayerState::kClanFieldNumber;
const int MLPlayerState::kTeamFieldNumber;
const int MLPlayerState::kAbsposFieldNumber;
const int MLPlayerState::kEyeangleFieldNumber;
const int MLPlayerState::kEyeangleFwdFieldNumber;
const int MLPlayerState::kHealthFieldNumber;
const int MLPlayerState::kArmorFieldNumber;
const int MLPlayerState::kFlashedFieldNumber;
const int MLPlayerState::kSmokedFieldNumber;
const int MLPlayerState::kMoneyFieldNumber;
const int MLPlayerState::kRoundKillsFieldNumber;
const int MLPlayerState::kRoundKillhsFieldNumber;
const int MLPlayerState::kBurningFieldNumber;
const int MLPlayerState::kHelmetFieldNumber;
const int MLPlayerState::kDefuseKitFieldNumber;
const int MLPlayerState::kWeaponsFieldNumber;
#endif  // !_MSC_VER

MLPlayerState::MLPlayerState()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MLPlayerState::InitAsDefaultInstance() {
  abspos_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
  eyeangle_ = const_cast< ::CMsgQAngle*>(&::CMsgQAngle::default_instance());
  eyeangle_fwd_ = const_cast< ::CMsgVector*>(&::CMsgVector::default_instance());
}

MLPlayerState::MLPlayerState(const MLPlayerState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MLPlayerState::SharedCtor() {
  _cached_size_ = 0;
  account_id_ = 0;
  user_id_ = 0;
  entindex_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  clan_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  team_ = 0;
  abspos_ = NULL;
  eyeangle_ = NULL;
  eyeangle_fwd_ = NULL;
  health_ = 0;
  armor_ = 0;
  flashed_ = 0;
  smoked_ = 0;
  money_ = 0;
  round_kills_ = 0;
  round_killhs_ = 0;
  burning_ = 0;
  helmet_ = false;
  defuse_kit_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MLPlayerState::~MLPlayerState() {
  SharedDtor();
}

void MLPlayerState::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (clan_ != &::google::protobuf::internal::kEmptyString) {
    delete clan_;
  }
  if (this != default_instance_) {
    delete abspos_;
    delete eyeangle_;
    delete eyeangle_fwd_;
  }
}

void MLPlayerState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MLPlayerState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MLPlayerState_descriptor_;
}

const MLPlayerState& MLPlayerState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_fatdemo_2eproto();
  return *default_instance_;
}

MLPlayerState* MLPlayerState::default_instance_ = NULL;

MLPlayerState* MLPlayerState::New() const {
  return new MLPlayerState;
}

void MLPlayerState::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    account_id_ = 0;
    user_id_ = 0;
    entindex_ = 0;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_clan()) {
      if (clan_ != &::google::protobuf::internal::kEmptyString) {
        clan_->clear();
      }
    }
    team_ = 0;
    if (has_abspos()) {
      if (abspos_ != NULL) abspos_->::CMsgVector::Clear();
    }
    if (has_eyeangle()) {
      if (eyeangle_ != NULL) eyeangle_->::CMsgQAngle::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_eyeangle_fwd()) {
      if (eyeangle_fwd_ != NULL) eyeangle_fwd_->::CMsgVector::Clear();
    }
    health_ = 0;
    armor_ = 0;
    flashed_ = 0;
    smoked_ = 0;
    money_ = 0;
    round_kills_ = 0;
    round_killhs_ = 0;
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    burning_ = 0;
    helmet_ = false;
    defuse_kit_ = false;
  }
  weapons_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MLPlayerState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 account_id = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &account_id_)));
          set_has_account_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_user_id;
        break;
      }

      // optional int32 user_id = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_user_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &user_id_)));
          set_has_user_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_entindex;
        break;
      }

      // optional int32 entindex = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_entindex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &entindex_)));
          set_has_entindex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_name;
        break;
      }

      // optional string name = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_clan;
        break;
      }

      // optional string clan = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_clan:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_clan()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->clan().data(), this->clan().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_team;
        break;
      }

      // optional .ETeam team = 6 [default = ET_Unknown];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_team:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::ETeam_IsValid(value)) {
            set_team(static_cast< ::ETeam >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_abspos;
        break;
      }

      // optional .CMsgVector abspos = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_abspos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_abspos()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_eyeangle;
        break;
      }

      // optional .CMsgQAngle eyeangle = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_eyeangle:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_eyeangle()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_eyeangle_fwd;
        break;
      }

      // optional .CMsgVector eyeangle_fwd = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_eyeangle_fwd:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_eyeangle_fwd()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_health;
        break;
      }

      // optional int32 health = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_health:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &health_)));
          set_has_health();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(88)) goto parse_armor;
        break;
      }

      // optional int32 armor = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_armor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &armor_)));
          set_has_armor();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(101)) goto parse_flashed;
        break;
      }

      // optional float flashed = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_flashed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &flashed_)));
          set_has_flashed();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(109)) goto parse_smoked;
        break;
      }

      // optional float smoked = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_smoked:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &smoked_)));
          set_has_smoked();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(112)) goto parse_money;
        break;
      }

      // optional int32 money = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_money:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &money_)));
          set_has_money();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(120)) goto parse_round_kills;
        break;
      }

      // optional int32 round_kills = 15;
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_round_kills:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &round_kills_)));
          set_has_round_kills();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(128)) goto parse_round_killhs;
        break;
      }

      // optional int32 round_killhs = 16;
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_round_killhs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &round_killhs_)));
          set_has_round_killhs();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(141)) goto parse_burning;
        break;
      }

      // optional float burning = 17;
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_burning:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &burning_)));
          set_has_burning();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(144)) goto parse_helmet;
        break;
      }

      // optional bool helmet = 18;
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_helmet:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &helmet_)));
          set_has_helmet();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(152)) goto parse_defuse_kit;
        break;
      }

      // optional bool defuse_kit = 19;
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_defuse_kit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &defuse_kit_)));
          set_has_defuse_kit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_weapons;
        break;
      }

      // repeated .MLWeaponState weapons = 20;
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_weapons:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_weapons()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(162)) goto parse_weapons;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MLPlayerState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 account_id = 1;
  if (has_account_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->account_id(), output);
  }

  // optional int32 user_id = 2;
  if (has_user_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->user_id(), output);
  }

  // optional int32 entindex = 3;
  if (has_entindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->entindex(), output);
  }

  // optional string name = 4;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      4, this->name(), output);
  }

  // optional string clan = 5;
  if (has_clan()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->clan().data(), this->clan().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->clan(), output);
  }

  // optional .ETeam team = 6 [default = ET_Unknown];
  if (has_team()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->team(), output);
  }

  // optional .CMsgVector abspos = 7;
  if (has_abspos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->abspos(), output);
  }

  // optional .CMsgQAngle eyeangle = 8;
  if (has_eyeangle()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->eyeangle(), output);
  }

  // optional .CMsgVector eyeangle_fwd = 9;
  if (has_eyeangle_fwd()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->eyeangle_fwd(), output);
  }

  // optional int32 health = 10;
  if (has_health()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->health(), output);
  }

  // optional int32 armor = 11;
  if (has_armor()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(11, this->armor(), output);
  }

  // optional float flashed = 12;
  if (has_flashed()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(12, this->flashed(), output);
  }

  // optional float smoked = 13;
  if (has_smoked()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(13, this->smoked(), output);
  }

  // optional int32 money = 14;
  if (has_money()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(14, this->money(), output);
  }

  // optional int32 round_kills = 15;
  if (has_round_kills()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(15, this->round_kills(), output);
  }

  // optional int32 round_killhs = 16;
  if (has_round_killhs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(16, this->round_killhs(), output);
  }

  // optional float burning = 17;
  if (has_burning()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(17, this->burning(), output);
  }

  // optional bool helmet = 18;
  if (has_helmet()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(18, this->helmet(), output);
  }

  // optional bool defuse_kit = 19;
  if (has_defuse_kit()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(19, this->defuse_kit(), output);
  }

  // repeated .MLWeaponState weapons = 20;
  for (int i = 0; i < this->weapons_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      20, this->weapons(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MLPlayerState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 account_id = 1;
  if (has_account_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->account_id(), target);
  }

  // optional int32 user_id = 2;
  if (has_user_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->user_id(), target);
  }

  // optional int32 entindex = 3;
  if (has_entindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->entindex(), target);
  }

  // optional string name = 4;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->name(), target);
  }

  // optional string clan = 5;
  if (has_clan()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->clan().data(), this->clan().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->clan(), target);
  }

  // optional .ETeam team = 6 [default = ET_Unknown];
  if (has_team()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->team(), target);
  }

  // optional .CMsgVector abspos = 7;
  if (has_abspos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->abspos(), target);
  }

  // optional .CMsgQAngle eyeangle = 8;
  if (has_eyeangle()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->eyeangle(), target);
  }

  // optional .CMsgVector eyeangle_fwd = 9;
  if (has_eyeangle_fwd()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->eyeangle_fwd(), target);
  }

  // optional int32 health = 10;
  if (has_health()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->health(), target);
  }

  // optional int32 armor = 11;
  if (has_armor()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(11, this->armor(), target);
  }

  // optional float flashed = 12;
  if (has_flashed()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(12, this->flashed(), target);
  }

  // optional float smoked = 13;
  if (has_smoked()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(13, this->smoked(), target);
  }

  // optional int32 money = 14;
  if (has_money()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(14, this->money(), target);
  }

  // optional int32 round_kills = 15;
  if (has_round_kills()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(15, this->round_kills(), target);
  }

  // optional int32 round_killhs = 16;
  if (has_round_killhs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(16, this->round_killhs(), target);
  }

  // optional float burning = 17;
  if (has_burning()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(17, this->burning(), target);
  }

  // optional bool helmet = 18;
  if (has_helmet()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(18, this->helmet(), target);
  }

  // optional bool defuse_kit = 19;
  if (has_defuse_kit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(19, this->defuse_kit(), target);
  }

  // repeated .MLWeaponState weapons = 20;
  for (int i = 0; i < this->weapons_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        20, this->weapons(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MLPlayerState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 account_id = 1;
    if (has_account_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->account_id());
    }

    // optional int32 user_id = 2;
    if (has_user_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->user_id());
    }

    // optional int32 entindex = 3;
    if (has_entindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->entindex());
    }

    // optional string name = 4;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string clan = 5;
    if (has_clan()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->clan());
    }

    // optional .ETeam team = 6 [default = ET_Unknown];
    if (has_team()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->team());
    }

    // optional .CMsgVector abspos = 7;
    if (has_abspos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->abspos());
    }

    // optional .CMsgQAngle eyeangle = 8;
    if (has_eyeangle()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->eyeangle());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .CMsgVector eyeangle_fwd = 9;
    if (has_eyeangle_fwd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->eyeangle_fwd());
    }

    // optional int32 health = 10;
    if (has_health()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->health());
    }

    // optional int32 armor = 11;
    if (has_armor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->armor());
    }

    // optional float flashed = 12;
    if (has_flashed()) {
      total_size += 1 + 4;
    }

    // optional float smoked = 13;
    if (has_smoked()) {
      total_size += 1 + 4;
    }

    // optional int32 money = 14;
    if (has_money()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->money());
    }

    // optional int32 round_kills = 15;
    if (has_round_kills()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->round_kills());
    }

    // optional int32 round_killhs = 16;
    if (has_round_killhs()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->round_killhs());
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional float burning = 17;
    if (has_burning()) {
      total_size += 2 + 4;
    }

    // optional bool helmet = 18;
    if (has_helmet()) {
      total_size += 2 + 1;
    }

    // optional bool defuse_kit = 19;
    if (has_defuse_kit()) {
      total_size += 2 + 1;
    }

  }
  // repeated .MLWeaponState weapons = 20;
  total_size += 2 * this->weapons_size();
  for (int i = 0; i < this->weapons_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->weapons(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MLPlayerState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MLPlayerState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MLPlayerState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MLPlayerState::MergeFrom(const MLPlayerState& from) {
  GOOGLE_CHECK_NE(&from, this);
  weapons_.MergeFrom(from.weapons_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_account_id()) {
      set_account_id(from.account_id());
    }
    if (from.has_user_id()) {
      set_user_id(from.user_id());
    }
    if (from.has_entindex()) {
      set_entindex(from.entindex());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_clan()) {
      set_clan(from.clan());
    }
    if (from.has_team()) {
      set_team(from.team());
    }
    if (from.has_abspos()) {
      mutable_abspos()->::CMsgVector::MergeFrom(from.abspos());
    }
    if (from.has_eyeangle()) {
      mutable_eyeangle()->::CMsgQAngle::MergeFrom(from.eyeangle());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_eyeangle_fwd()) {
      mutable_eyeangle_fwd()->::CMsgVector::MergeFrom(from.eyeangle_fwd());
    }
    if (from.has_health()) {
      set_health(from.health());
    }
    if (from.has_armor()) {
      set_armor(from.armor());
    }
    if (from.has_flashed()) {
      set_flashed(from.flashed());
    }
    if (from.has_smoked()) {
      set_smoked(from.smoked());
    }
    if (from.has_money()) {
      set_money(from.money());
    }
    if (from.has_round_kills()) {
      set_round_kills(from.round_kills());
    }
    if (from.has_round_killhs()) {
      set_round_killhs(from.round_killhs());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_burning()) {
      set_burning(from.burning());
    }
    if (from.has_helmet()) {
      set_helmet(from.helmet());
    }
    if (from.has_defuse_kit()) {
      set_defuse_kit(from.defuse_kit());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MLPlayerState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MLPlayerState::CopyFrom(const MLPlayerState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MLPlayerState::IsInitialized() const {

  return true;
}

void MLPlayerState::Swap(MLPlayerState* other) {
  if (other != this) {
    std::swap(account_id_, other->account_id_);
    std::swap(user_id_, other->user_id_);
    std::swap(entindex_, other->entindex_);
    std::swap(name_, other->name_);
    std::swap(clan_, other->clan_);
    std::swap(team_, other->team_);
    std::swap(abspos_, other->abspos_);
    std::swap(eyeangle_, other->eyeangle_);
    std::swap(eyeangle_fwd_, other->eyeangle_fwd_);
    std::swap(health_, other->health_);
    std::swap(armor_, other->armor_);
    std::swap(flashed_, other->flashed_);
    std::swap(smoked_, other->smoked_);
    std::swap(money_, other->money_);
    std::swap(round_kills_, other->round_kills_);
    std::swap(round_killhs_, other->round_killhs_);
    std::swap(burning_, other->burning_);
    std::swap(helmet_, other->helmet_);
    std::swap(defuse_kit_, other->defuse_kit_);
    weapons_.Swap(&other->weapons_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MLPlayerState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MLPlayerState_descriptor_;
  metadata.reflection = MLPlayerState_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MLGameState::kMatchFieldNumber;
const int MLGameState::kRoundFieldNumber;
const int MLGameState::kPlayersFieldNumber;
#endif  // !_MSC_VER

MLGameState::MLGameState()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MLGameState::InitAsDefaultInstance() {
  match_ = const_cast< ::MLMatchState*>(&::MLMatchState::default_instance());
  round_ = const_cast< ::MLRoundState*>(&::MLRoundState::default_instance());
}

MLGameState::MLGameState(const MLGameState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MLGameState::SharedCtor() {
  _cached_size_ = 0;
  match_ = NULL;
  round_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MLGameState::~MLGameState() {
  SharedDtor();
}

void MLGameState::SharedDtor() {
  if (this != default_instance_) {
    delete match_;
    delete round_;
  }
}

void MLGameState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MLGameState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MLGameState_descriptor_;
}

const MLGameState& MLGameState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_fatdemo_2eproto();
  return *default_instance_;
}

MLGameState* MLGameState::default_instance_ = NULL;

MLGameState* MLGameState::New() const {
  return new MLGameState;
}

void MLGameState::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_match()) {
      if (match_ != NULL) match_->::MLMatchState::Clear();
    }
    if (has_round()) {
      if (round_ != NULL) round_->::MLRoundState::Clear();
    }
  }
  players_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MLGameState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .MLMatchState match = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_match()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_round;
        break;
      }

      // optional .MLRoundState round = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_round:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_round()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_players;
        break;
      }

      // repeated .MLPlayerState players = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_players:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_players()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_players;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MLGameState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .MLMatchState match = 1;
  if (has_match()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->match(), output);
  }

  // optional .MLRoundState round = 2;
  if (has_round()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->round(), output);
  }

  // repeated .MLPlayerState players = 3;
  for (int i = 0; i < this->players_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->players(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MLGameState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .MLMatchState match = 1;
  if (has_match()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->match(), target);
  }

  // optional .MLRoundState round = 2;
  if (has_round()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->round(), target);
  }

  // repeated .MLPlayerState players = 3;
  for (int i = 0; i < this->players_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->players(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MLGameState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .MLMatchState match = 1;
    if (has_match()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->match());
    }

    // optional .MLRoundState round = 2;
    if (has_round()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->round());
    }

  }
  // repeated .MLPlayerState players = 3;
  total_size += 1 * this->players_size();
  for (int i = 0; i < this->players_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->players(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MLGameState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MLGameState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MLGameState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MLGameState::MergeFrom(const MLGameState& from) {
  GOOGLE_CHECK_NE(&from, this);
  players_.MergeFrom(from.players_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_match()) {
      mutable_match()->::MLMatchState::MergeFrom(from.match());
    }
    if (from.has_round()) {
      mutable_round()->::MLRoundState::MergeFrom(from.round());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MLGameState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MLGameState::CopyFrom(const MLGameState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MLGameState::IsInitialized() const {

  return true;
}

void MLGameState::Swap(MLGameState* other) {
  if (other != this) {
    std::swap(match_, other->match_);
    std::swap(round_, other->round_);
    players_.Swap(&other->players_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MLGameState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MLGameState_descriptor_;
  metadata.reflection = MLGameState_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MLDemoHeader::kMapNameFieldNumber;
const int MLDemoHeader::kTickRateFieldNumber;
const int MLDemoHeader::kVersionFieldNumber;
const int MLDemoHeader::kSteamUniverseFieldNumber;
#endif  // !_MSC_VER

MLDemoHeader::MLDemoHeader()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MLDemoHeader::InitAsDefaultInstance() {
}

MLDemoHeader::MLDemoHeader(const MLDemoHeader& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MLDemoHeader::SharedCtor() {
  _cached_size_ = 0;
  map_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  tick_rate_ = 0;
  version_ = 0u;
  steam_universe_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MLDemoHeader::~MLDemoHeader() {
  SharedDtor();
}

void MLDemoHeader::SharedDtor() {
  if (map_name_ != &::google::protobuf::internal::kEmptyString) {
    delete map_name_;
  }
  if (this != default_instance_) {
  }
}

void MLDemoHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MLDemoHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MLDemoHeader_descriptor_;
}

const MLDemoHeader& MLDemoHeader::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_fatdemo_2eproto();
  return *default_instance_;
}

MLDemoHeader* MLDemoHeader::default_instance_ = NULL;

MLDemoHeader* MLDemoHeader::New() const {
  return new MLDemoHeader;
}

void MLDemoHeader::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_map_name()) {
      if (map_name_ != &::google::protobuf::internal::kEmptyString) {
        map_name_->clear();
      }
    }
    tick_rate_ = 0;
    version_ = 0u;
    steam_universe_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MLDemoHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string map_name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_map_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->map_name().data(), this->map_name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_tick_rate;
        break;
      }

      // optional int32 tick_rate = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_tick_rate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &tick_rate_)));
          set_has_tick_rate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_version;
        break;
      }

      // optional uint32 version = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_steam_universe;
        break;
      }

      // optional uint32 steam_universe = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_steam_universe:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &steam_universe_)));
          set_has_steam_universe();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MLDemoHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string map_name = 1;
  if (has_map_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->map_name().data(), this->map_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->map_name(), output);
  }

  // optional int32 tick_rate = 2;
  if (has_tick_rate()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->tick_rate(), output);
  }

  // optional uint32 version = 3;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->version(), output);
  }

  // optional uint32 steam_universe = 4;
  if (has_steam_universe()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->steam_universe(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MLDemoHeader::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string map_name = 1;
  if (has_map_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->map_name().data(), this->map_name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->map_name(), target);
  }

  // optional int32 tick_rate = 2;
  if (has_tick_rate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->tick_rate(), target);
  }

  // optional uint32 version = 3;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->version(), target);
  }

  // optional uint32 steam_universe = 4;
  if (has_steam_universe()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->steam_universe(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MLDemoHeader::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string map_name = 1;
    if (has_map_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->map_name());
    }

    // optional int32 tick_rate = 2;
    if (has_tick_rate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->tick_rate());
    }

    // optional uint32 version = 3;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->version());
    }

    // optional uint32 steam_universe = 4;
    if (has_steam_universe()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->steam_universe());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MLDemoHeader::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MLDemoHeader* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MLDemoHeader*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MLDemoHeader::MergeFrom(const MLDemoHeader& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_map_name()) {
      set_map_name(from.map_name());
    }
    if (from.has_tick_rate()) {
      set_tick_rate(from.tick_rate());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_steam_universe()) {
      set_steam_universe(from.steam_universe());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MLDemoHeader::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MLDemoHeader::CopyFrom(const MLDemoHeader& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MLDemoHeader::IsInitialized() const {

  return true;
}

void MLDemoHeader::Swap(MLDemoHeader* other) {
  if (other != this) {
    std::swap(map_name_, other->map_name_);
    std::swap(tick_rate_, other->tick_rate_);
    std::swap(version_, other->version_);
    std::swap(steam_universe_, other->steam_universe_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MLDemoHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MLDemoHeader_descriptor_;
  metadata.reflection = MLDemoHeader_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MLTick::kTickCountFieldNumber;
const int MLTick::kStateFieldNumber;
const int MLTick::kEventsFieldNumber;
#endif  // !_MSC_VER

MLTick::MLTick()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MLTick::InitAsDefaultInstance() {
  state_ = const_cast< ::MLGameState*>(&::MLGameState::default_instance());
}

MLTick::MLTick(const MLTick& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MLTick::SharedCtor() {
  _cached_size_ = 0;
  tick_count_ = 0;
  state_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MLTick::~MLTick() {
  SharedDtor();
}

void MLTick::SharedDtor() {
  if (this != default_instance_) {
    delete state_;
  }
}

void MLTick::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MLTick::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MLTick_descriptor_;
}

const MLTick& MLTick::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_fatdemo_2eproto();
  return *default_instance_;
}

MLTick* MLTick::default_instance_ = NULL;

MLTick* MLTick::New() const {
  return new MLTick;
}

void MLTick::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    tick_count_ = 0;
    if (has_state()) {
      if (state_ != NULL) state_->::MLGameState::Clear();
    }
  }
  events_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MLTick::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 tick_count = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &tick_count_)));
          set_has_tick_count();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_state;
        break;
      }

      // optional .MLGameState state = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_state:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_state()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_events;
        break;
      }

      // repeated .MLEvent events = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_events:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_events()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_events;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MLTick::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 tick_count = 1;
  if (has_tick_count()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->tick_count(), output);
  }

  // optional .MLGameState state = 2;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->state(), output);
  }

  // repeated .MLEvent events = 3;
  for (int i = 0; i < this->events_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->events(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MLTick::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional int32 tick_count = 1;
  if (has_tick_count()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->tick_count(), target);
  }

  // optional .MLGameState state = 2;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->state(), target);
  }

  // repeated .MLEvent events = 3;
  for (int i = 0; i < this->events_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->events(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MLTick::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 tick_count = 1;
    if (has_tick_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->tick_count());
    }

    // optional .MLGameState state = 2;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->state());
    }

  }
  // repeated .MLEvent events = 3;
  total_size += 1 * this->events_size();
  for (int i = 0; i < this->events_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->events(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MLTick::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MLTick* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MLTick*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MLTick::MergeFrom(const MLTick& from) {
  GOOGLE_CHECK_NE(&from, this);
  events_.MergeFrom(from.events_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tick_count()) {
      set_tick_count(from.tick_count());
    }
    if (from.has_state()) {
      mutable_state()->::MLGameState::MergeFrom(from.state());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MLTick::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MLTick::CopyFrom(const MLTick& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MLTick::IsInitialized() const {

  return true;
}

void MLTick::Swap(MLTick* other) {
  if (other != this) {
    std::swap(tick_count_, other->tick_count_);
    std::swap(state_, other->state_);
    events_.Swap(&other->events_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MLTick::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MLTick_descriptor_;
  metadata.reflection = MLTick_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
